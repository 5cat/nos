/*
 * Copyright 2022 Nebuly.ai
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package plan

import (
	"github.com/nebuly-ai/nebulnetes/pkg/gpu"
	"github.com/nebuly-ai/nebulnetes/pkg/gpu/mig"
	"github.com/nebuly-ai/nebulnetes/pkg/util"
)

type CreateOperation struct {
	// MigProfile corresponds to the profile(s) that need to be created
	MigProfile mig.Profile
	// Quantity is the amount of MigProfiles that need to be created
	Quantity int
}

type DeleteOperation struct {
	// Resources are the MIG resources that needs to be deleted
	Resources gpu.DeviceList
}

func (o DeleteOperation) GetMigProfileName() mig.ProfileName {
	if len(o.Resources) > 0 {
		return mig.GetMigProfileName(o.Resources[0])
	}
	return ""
}

func (o DeleteOperation) Equal(other DeleteOperation) bool {
	return util.UnorderedEqual(o.Resources, other.Resources)
}

// OperationStatus represents the outcome of the execution of an operation
type OperationStatus struct {
	// PluginRestartRequired indicates if the operation execution requires the NVIDIA device plugin to be restarted
	PluginRestartRequired bool
	// Err corresponds to any error generated by the operation execution
	Err error
}

type CreateOperationList []CreateOperation

func (c CreateOperationList) Flatten() mig.ProfileList {
	res := make(mig.ProfileList, 0)
	for _, op := range c {
		for i := 0; i < op.Quantity; i++ {
			res = append(res, op.MigProfile)
		}
	}
	return res
}

func (c CreateOperationList) Equal(other CreateOperationList) bool {
	if len(c) != len(other) {
		return false
	}
	return util.UnorderedEqual(c, other)
}

type DeleteOperationList []DeleteOperation

func (l DeleteOperationList) Equal(other DeleteOperationList) bool {
	if len(l) != len(other) {
		return false
	}
	return util.UnorderedEqual(l, other)
}
